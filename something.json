{
    "_CACHED_SLOTS": [
        "_cs_channel_mentions",
        "_cs_raw_mentions",
        "_cs_clean_content",
        "_cs_raw_channel_mentions",
        "_cs_raw_role_mentions",
        "_cs_system_content",
        "_cs_guild"
    ],
    "__doc__": "Represents a message from Discord.\n\n    There should be no need to create one of these manually.\n\n    Attributes\n    -----------\n    tts: :class:`bool`\n        Specifies if the message was done with text-to-speech.\n        This can only be accurately received in :func:`on_message` due to\n        a discord limitation.\n    type: :class:`MessageType`\n        The type of message. In most cases this should not be checked, but it is helpful\n        in cases where it might be a system message for :attr:`system_content`.\n    author: :class:`abc.User`\n        A :class:`Member` that sent the message. If :attr:`channel` is a\n        private channel or the user has the left the guild, then it is a :class:`User` instead.\n    content: :class:`str`\n        The actual contents of the message.\n    nonce\n        The value used by the discord guild and the client to verify that the message is successfully sent.\n        This is typically non-important.\n    embeds: List[:class:`Embed`]\n        A list of embeds the message has.\n    channel: Union[:class:`abc.Messageable`]\n        The :class:`TextChannel` that the message was sent from.\n        Could be a :class:`DMChannel` or :class:`GroupChannel` if it's a private message.\n    call: Optional[:class:`CallMessage`]\n        The call that the message refers to. This is only applicable to messages of type\n        :attr:`MessageType.call`.\n    mention_everyone: :class:`bool`\n        Specifies if the message mentions everyone.\n\n        .. note::\n\n            This does not check if the ``@everyone`` or the ``@here`` text is in the message itself.\n            Rather this boolean indicates if either the ``@everyone`` or the ``@here`` text is in the message\n            **and** it did end up mentioning.\n    mentions: List[:class:`abc.User`]\n        A list of :class:`Member` that were mentioned. If the message is in a private message\n        then the list will be of :class:`User` instead. For messages that are not of type\n        :attr:`MessageType.default`\\, this array can be used to aid in system messages.\n        For more information, see :attr:`system_content`.\n\n        .. warning::\n\n            The order of the mentions list is not in any particular order so you should\n            not rely on it. This is a discord limitation, not one with the library.\n    channel_mentions: List[:class:`abc.GuildChannel`]\n        A list of :class:`abc.GuildChannel` that were mentioned. If the message is in a private message\n        then the list is always empty.\n    role_mentions: List[:class:`Role`]\n        A list of :class:`Role` that were mentioned. If the message is in a private message\n        then the list is always empty.\n    id: :class:`int`\n        The message ID.\n    webhook_id: Optional[:class:`int`]\n        If this message was sent by a webhook, then this is the webhook ID's that sent this\n        message.\n    attachments: List[:class:`Attachment`]\n        A list of attachments given to a message.\n    pinned: :class:`bool`\n        Specifies if the message is currently pinned.\n    flags: :class:`MessageFlags`\n        Extra features of the message.\n\n        .. versionadded:: 1.3\n\n    reactions : List[:class:`Reaction`]\n        Reactions to a message. Reactions can be either custom emoji or standard unicode emoji.\n    activity: Optional[:class:`dict`]\n        The activity associated with this message. Sent with Rich-Presence related messages that for\n        example, request joining, spectating, or listening to or with another member.\n\n        It is a dictionary with the following optional keys:\n\n        - ``type``: An integer denoting the type of message activity being requested.\n        - ``party_id``: The party ID associated with the party.\n    application: Optional[:class:`dict`]\n        The rich presence enabled application associated with this message.\n\n        It is a dictionary with the following keys:\n\n        - ``id``: A string representing the application's ID.\n        - ``name``: A string representing the application's name.\n        - ``description``: A string representing the application's description.\n        - ``icon``: A string representing the icon ID of the application.\n        - ``cover_image``: A string representing the embed's image asset ID.\n    ",
    "__module__": "discord.message",
    "__slotnames__": [
        "_edited_timestamp",
        "tts",
        "content",
        "channel",
        "webhook_id",
        "mention_everyone",
        "embeds",
        "id",
        "mentions",
        "author",
        "_cs_channel_mentions",
        "_cs_raw_mentions",
        "attachments",
        "_cs_clean_content",
        "_cs_raw_channel_mentions",
        "nonce",
        "pinned",
        "role_mentions",
        "_cs_raw_role_mentions",
        "type",
        "call",
        "flags",
        "_cs_system_content",
        "_cs_guild",
        "_state",
        "reactions",
        "application",
        "activity"
    ],
    "attachments": [],
    "channel_mentions": [],
    "clean_content": "f/jsk py\n```py\nimport discord\nimport json\n\ndictionary = {}\nallowed_types = [int, str, bool, list, type, dict]\n\ndef is_jsonable(x:object):\n    try:\n        json.dumps(x)\n        return True\n    except:\n        return False\n\ndef to_dict(something: object):\n    for key in dir(something):\n        try:\n            value = getattr(something, key)\n        except AttributeError:\n            continue\n\n        if type(value) in allowed_types:\n            if is_jsonable({key:value}):\n                dictionary[key] = value\n        elif type(value)==object:\n            try:\n                value.__already_looped__\n            except AttributeError:\n                value.__already_looped__ = True\n                dictionary[key] = to_dict(value)\n    return dictionary\n\n\nwith open(\"something.json\", \"w+\") as f:\n    json.dump(to_dict(something = _message), f, indent=4 )\n\n```",
    "content": "f/jsk py\n```py\nimport discord\nimport json\n\ndictionary = {}\nallowed_types = [int, str, bool, list, type, dict]\n\ndef is_jsonable(x:object):\n    try:\n        json.dumps(x)\n        return True\n    except:\n        return False\n\ndef to_dict(something: object):\n    for key in dir(something):\n        try:\n            value = getattr(something, key)\n        except AttributeError:\n            continue\n\n        if type(value) in allowed_types:\n            if is_jsonable({key:value}):\n                dictionary[key] = value\n        elif type(value)==object:\n            try:\n                value.__already_looped__\n            except AttributeError:\n                value.__already_looped__ = True\n                dictionary[key] = to_dict(value)\n    return dictionary\n\n\nwith open(\"something.json\", \"w+\") as f:\n    json.dump(to_dict(something = _message), f, indent=4 )\n\n```",
    "embeds": [],
    "id": 753116534771286087,
    "jump_url": "https://discord.com/channels/336642139381301249/381963689470984203/753116534771286087",
    "mention_everyone": false,
    "mentions": [],
    "nonce": "753116525895876608",
    "pinned": false,
    "raw_channel_mentions": [],
    "raw_mentions": [],
    "raw_role_mentions": [],
    "reactions": [],
    "role_mentions": [],
    "system_content": "f/jsk py\n```py\nimport discord\nimport json\n\ndictionary = {}\nallowed_types = [int, str, bool, list, type, dict]\n\ndef is_jsonable(x:object):\n    try:\n        json.dumps(x)\n        return True\n    except:\n        return False\n\ndef to_dict(something: object):\n    for key in dir(something):\n        try:\n            value = getattr(something, key)\n        except AttributeError:\n            continue\n\n        if type(value) in allowed_types:\n            if is_jsonable({key:value}):\n                dictionary[key] = value\n        elif type(value)==object:\n            try:\n                value.__already_looped__\n            except AttributeError:\n                value.__already_looped__ = True\n                dictionary[key] = to_dict(value)\n    return dictionary\n\n\nwith open(\"something.json\", \"w+\") as f:\n    json.dump(to_dict(something = _message), f, indent=4 )\n\n```",
    "tts": false
}